import { Request, Response } from 'express';
import { StatusCodes } from 'http-status-codes';
import mongoose from 'mongoose';

import { DailyTask, UserDailyTask } from '../models/DailyTask.model';
import Quiz from '../models/Quiz.model';
import QuizAttempt from '../models/QuizAttempt.model';
import AsyncHandler from '../middleware/AsyncHandler';
import { BadRequestError, NotFoundError, UnauthorizedError } from '../errors';

async function getRandomUnansweredQuestions(userId: string, count: number = 5) {
	const attemptedQuizzes = await QuizAttempt.find({ user: userId })
		.select('quiz')
		.distinct('quiz');

	const unansweredQuizzes = await Quiz.find({
		_id: { $nin: attemptedQuizzes },
		isPublic: true,
	}).populate('questions');

	const selectedQuizzes = unansweredQuizzes
		.sort(() => Math.random() - 0.5)
		.slice(0, count);

	return selectedQuizzes;
}

class DailyTaskController {
	// Get current daily tasks for the authenticated user
	static getDailyTasks = AsyncHandler(async (req: Request, res: Response) => {
		if (!req.user) {
			throw new UnauthorizedError('Unauthorized');
		}

		// Today's date (start of day)
		const today = new Date();
		today.setHours(0, 0, 0, 0);

		// First check for any existing task for today (completed or not)
		const existingUserTask = await UserDailyTask.findOne({
			user: req.user?.userId,
			assignedDate: { $gte: today },
		}).populate({
			path: 'task',
			populate: {
				path: 'questions',
				model: 'Quiz',
			},
		});

		if (existingUserTask) {
			// Return the existing task with full question details
			res.status(StatusCodes.OK).json({
				tasks: [
					{
						id: existingUserTask._id,
						taskId: (existingUserTask.task as any)._id,
						name: (existingUserTask.task as any).name,
						description: (existingUserTask.task as any).description,
						type: (existingUserTask.task as any).type,
						requirement: (existingUserTask.task as any).requirement,
						points: (existingUserTask.task as any).points,
						progress: existingUserTask.progress,
						completed: existingUserTask.completed,
						completedAt: existingUserTask.completedAt,
						questions: (existingUserTask.task as any).questions,
					},
				],
				stats: {
					total: 1,
					completed: existingUserTask.completed ? 1 : 0,
					incomplete: existingUserTask.completed ? 0 : 1,
					progressPercentage: existingUserTask.completed ? 100 : 0,
				},
			});
			return;
		}

		// Only create a new task if no task exists for today
		const randomQuizzes = await getRandomUnansweredQuestions(
			req.user?.userId.toString(),
			1 // Only get one quiz
		);

		if (randomQuizzes.length > 0) {
			const autoTask = new DailyTask({
				name: 'Daily Practice',
				description: 'Complete a random question to earn points!',
				type: 'auto_generated',
				requirement: 1, // Only require one question
				points: 10, // 10 points per question
				isActive: true,
				isAutoGenerated: true,
				questions: [randomQuizzes[0]._id], // Only use the first quiz
			});
			await autoTask.save();

			// Create user task assignment
			const newUserTask = new UserDailyTask({
				user: req.user?.userId,
				task: autoTask._id,
				assignedDate: today,
			});
			await newUserTask.save();

			// Populate the task with full question details
			await autoTask.populate('questions');

			res.status(StatusCodes.OK).json({
				tasks: [
					{
						id: newUserTask._id,
						taskId: autoTask._id,
						name: autoTask.name,
						description: autoTask.description,
						type: autoTask.type,
						requirement: autoTask.requirement,
						points: autoTask.points,
						progress: 0,
						completed: false,
						completedAt: null,
						questions: autoTask.questions,
					},
				],
				stats: {
					total: 1,
					completed: 0,
					incomplete: 1,
					progressPercentage: 0,
				},
			});
			return;
		}

		// If no questions available, return empty tasks
		res.status(StatusCodes.OK).json({
			tasks: [],
			stats: {
				total: 0,
				completed: 0,
				incomplete: 0,
				progressPercentage: 0,
			},
		});
	});

	// Update user's progress on a task (manual update for certain task types)
	static updateTaskProgress = AsyncHandler(
		async (req: Request, res: Response) => {
			const { taskId, progress } = req.body;
			const userId = req.currentUser?.userId;

			if (!userId) {
				throw new BadRequestError('User ID is required');
			}

			if (!mongoose.Types.ObjectId.isValid(taskId)) {
				throw new BadRequestError('Invalid task ID');
			}

			// Today's date (start of day)
			const today = new Date();
			today.setHours(0, 0, 0, 0);

			// Get the task
			const task = await DailyTask.findById(taskId);

			if (!task) {
				throw new NotFoundError('Task not found');
			}

			// Get or create user task
			let userTask = await UserDailyTask.findOne({
				user: userId,
				task: taskId,
				assignedDate: { $gte: today },
			});

			if (!userTask) {
				userTask = new UserDailyTask({
					user: userId,
					task: taskId,
					assignedDate: today,
				});
			}

			// Update progress
			const newProgress = userTask.progress + progress;

			// Check if task is completed
			if (newProgress >= task.requirement && !userTask.completed) {
				userTask.progress = task.requirement;
				userTask.completed = true;
				userTask.completedAt = new Date();
			} else {
				userTask.progress = newProgress;
			}

			await userTask.save();

			res.status(StatusCodes.OK).json({
				message: 'Task progress updated',
				task: {
					id: userTask._id,
					taskId: task._id,
					name: task.name,
					description: task.description,
					type: task.type,
					requirement: task.requirement,
					points: task.points,
					progress: userTask.progress,
					completed: userTask.completed,
					completedAt: userTask.completedAt,
				},
			});
		}
	);

	static createDailyTask = AsyncHandler(async (req: Request, res: Response) => {
		const { title, description, type, criteria, reward } = req.body;

		const dailyTask = new DailyTask({
			title,
			description,
			type,
			criteria,
			reward,
			isActive: true,
		});

		await dailyTask.save();

		res.status(StatusCodes.CREATED).json(dailyTask);
	});

	static getUserDailyTasks = AsyncHandler(
		async (req: Request, res: Response) => {
			const userId = req.currentUser?.userId;
			if (!userId) {
				throw new BadRequestError('User ID is required');
			}

			const today = new Date();
			today.setHours(0, 0, 0, 0);

			const userTasks = await UserDailyTask.find({
				user: userId,
				assignedDate: { $gte: today },
			}).populate('task');

			res.status(StatusCodes.OK).json(userTasks);
		}
	);

	static checkAndUpdateTimeSpentTask = AsyncHandler(
		async (req: Request, res: Response) => {
			const { timeSpent } = req.body;
			const userId = req.currentUser?.userId;

			if (!userId) {
				throw new BadRequestError('User ID is required');
			}

			const today = new Date();
			today.setHours(0, 0, 0, 0);

			// Find time-based tasks
			const timeTasks = await UserDailyTask.find({
				user: userId,
				assignedDate: { $gte: today },
				completed: false,
			}).populate({
				path: 'task',
				match: {
					'criteria.type': 'time_spent',
					isActive: true,
				},
			});

			for (const userTask of timeTasks) {
				const task = userTask.task as any;
				if (!task) continue;

				const newProgress = userTask.progress + timeSpent;
				if (newProgress >= task.criteria.target) {
					userTask.progress = task.criteria.target;
					userTask.completed = true;
					userTask.completedAt = new Date();
				} else {
					userTask.progress = newProgress;
				}

				await userTask.save();
			}

			res.status(StatusCodes.OK).json({ message: 'Time spent tasks updated' });
		}
	);

	static checkAndUpdateQuizTask = AsyncHandler(
		async (req: Request, res: Response) => {
			const { correctAnswers } = req.body;
			const userId = req.currentUser?.userId;

			if (!userId) {
				throw new BadRequestError('User ID is required');
			}

			const today = new Date();
			today.setHours(0, 0, 0, 0);

			// Find quiz-based tasks
			const quizTasks = await UserDailyTask.find({
				user: userId,
				assignedDate: { $gte: today },
				completed: false,
			}).populate({
				path: 'task',
				match: {
					'criteria.type': 'correct_answers',
					isActive: true,
				},
			});

			for (const userTask of quizTasks) {
				const task = userTask.task as any;
				if (!task) continue;

				const newProgress = userTask.progress + correctAnswers;
				if (newProgress >= task.criteria.target) {
					userTask.progress = task.criteria.target;
					userTask.completed = true;
					userTask.completedAt = new Date();
				} else {
					userTask.progress = newProgress;
				}

				await userTask.save();
			}

			res.status(StatusCodes.OK).json({ message: 'Quiz tasks updated' });
		}
	);
}

export default DailyTaskController;
